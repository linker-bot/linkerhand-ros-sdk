#!/usr/bin/env python3
import rospy,rospkg
import signal
from sensor_msgs.msg import JointState
from std_msgs.msg import String
import can
import json
import yaml
import time
import threading
import sys
import os
import subprocess
from std_msgs.msg import Header, Float32MultiArray
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from utils.linker_hand_l20_can import LinkerHandL20Can
from utils.linker_hand_l10_can import LinkerHandL10Can
from utils.color_msg import ColorMsg
global package_path
# 创建 rospkg.RosPack 对象
rospack = rospkg.RosPack()
# 获取指定包的路径
package_name = "linker_hand_sdk_ros"
package_path = rospack.get_path(package_name)
class LinkerHand:
    def __init__(self):
        rospy.init_node('linker_hand_sdk', anonymous=True)
        self.password = ""
        self.can_status = False
        self.load_yaml()
        time.sleep(0.1)
        # 初始化锁
        self.lock = threading.Lock()
        print(sys.platform)
        if sys.platform == "linux":
            while True:
                self.open_can0()
                time.sleep(0.1)
                if self.is_can_up_sysfs() == True:
                    ColorMsg(msg="CAN0端口已经打开", color="green")
                    break
                else:
                    ColorMsg(msg="CAN0端口通讯失败，请检查CAN设备是否接入，3秒后自动重试", color="yellow")
                    time.sleep(3)
                    continue
        if not self.left_hand_exists and not self.right_hand_exists:
            rospy.logerr("Linker Hand设备不存在，如硬件已连接，请检查配置文件")
            return

        self.rate = rospy.Rate(60)  # 设置频率为 60Hz
        
        if self.left_hand_exists:
            if self.left_hand_joint == 16 or self.left_hand_joint == 17:
                self.init_left_hand_l20()
            elif self.left_hand_joint == 10:
                self.init_left_hand_l10()

        if self.right_hand_exists:
            if self.right_hand_joint == 16 or self.right_hand_joint == 17:
                self.init_right_hand_l20()
            elif self.right_hand_joint == 10:
                self.init_right_hand_l10()
        self.shutdown_flag = threading.Event()
        self.hand_setting_sub = rospy.Subscriber("/cb_hand_setting_cmd", String, self.hand_setting_cb)

    def init_left_hand_l20(self):
        """Initialize left hand settings and subscribers."""
        ColorMsg(msg=f"L20左手", color="green")
        self.lh_l = LinkerHandL20Can(can_channel="can0", baudrate=1000000, can_id=0x28, config=self.config)
        self.lh_l.request_device_info()
        self.lh_l_last_pose = []
        # 创建can通讯线程
        self.left_hand_init_pose = [255,255,255,255,255,255,10,100,180,240,245,255,255,255,255,255,255,255,255,255]
        finger_base, yaw_angles, thumb_yaw, finger_tip = self.pose_slice(p=self.left_hand_init_pose)
        # 左手还原到原始位置
        self.send(finger_base, yaw_angles, thumb_yaw, finger_tip,self.lh_l)
        # 创建can通讯线程
        self.can_left_thread = threading.Thread(target=self.can_pub,args=("left",self.left_hand_joint))
        self.can_left_thread.daemon = True
        self.can_left_thread.start()
        # 左手发布状态
        self.pub_left_status = rospy.Publisher("/cb_left_hand_state", JointState, queue_size=10)
        rospy.Timer(rospy.Duration(1.0 / 60.0), self.pub_left_status_cb)
        self.lh_l_sub = rospy.Subscriber("/cb_left_hand_control_cmd", JointState, self.left_hand_cb, queue_size=1)
        self.lh_l_pressure_pub = rospy.Publisher("/cb_left_hand_touch", Float32MultiArray, queue_size=10)
        rospy.Timer(rospy.Duration(1.0 / 60.0), self.pub_left_touch_cb)
        
    def init_right_hand_l20(self):
        """Initialize right hand settings and subscribers."""
        ColorMsg(msg=f"L20右手", color="green")
        self.lh_r = LinkerHandL20Can(can_channel="can0", baudrate=1000000, can_id=0x27, config=self.config)
        self.lh_r.request_device_info()
        
        self.lh_r_last_pose = []
        # 创建can通讯线程
        self.right_hand_init_pose = [255,255,255,255,255,255,10,100,180,240,245,255,255,255,255,255,255,255,255,255]
        finger_base, yaw_angles, thumb_yaw, finger_tip = self.pose_slice(p=self.right_hand_init_pose)
        # 左手还原到原始位置
        self.send(finger_base, yaw_angles, thumb_yaw, finger_tip,self.lh_r)
        # 创建can通讯线程
        self.can_right_thread = threading.Thread(target=self.can_pub,args=("right",self.right_hand_joint))
        self.can_right_thread.daemon = True
        self.can_right_thread.start()
        # 右手发布状态
        self.pub_right_status = rospy.Publisher("/cb_right_hand_state", JointState, queue_size=10)
        rospy.Timer(rospy.Duration(1.0 / 60.0), self.pub_right_status_cb)
        self.lh_r_sub = rospy.Subscriber("/cb_right_hand_control_cmd", JointState, self.right_hand_cb,queue_size=1)
        
        self.lh_r_pressure_pub = rospy.Publisher("/cb_right_hand_touch", Float32MultiArray, queue_size=10)
        rospy.Timer(rospy.Duration(1.0 / 60.0), self.pub_right_touch_cb)

    """ ---------------------一下为L10控制方法---------------------------- """
    def init_left_hand_l10(self):
        ColorMsg(msg=f"L10左手", color="green")
        self.lh_l_last_pose = []
        self.lh_l = LinkerHandL10Can(config=self.config,can_id=0x28)
        # 创建can通讯线程
        self.left_hand_init_pose = [255, 128, 255, 255, 255, 255, 128, 128, 128, 128]
        self.send_l10(self.left_hand_init_pose, self.lh_l)
        # 创建can通讯线程
        self.can_left_thread = threading.Thread(target=self.can_pub,args=("left",self.left_hand_joint))
        self.can_left_thread.daemon = True
        self.can_left_thread.start()
        # 左手发布状态
        self.pub_left_status = rospy.Publisher("/cb_left_hand_state", JointState, queue_size=10)
        rospy.Timer(rospy.Duration(1.0 / 60.0), self.pub_left_status_cb)
        self.lh_l_sub = rospy.Subscriber("/cb_left_hand_control_cmd", JointState, self.left_hand_cb)

    def init_right_hand_l10(self):
        ColorMsg(msg=f"L10右手", color="green")
        self.lh_r_last_pose = []
        self.lh_r = LinkerHandL10Can(config=self.config,can_id=0x27)
        # 创建can通讯线程
        self.right_hand_init_pose = [255, 128, 255, 255, 255, 255, 128, 128, 128, 128]
        self.send_l10(self.right_hand_init_pose, self.lh_r)
        # 创建can通讯线程
        self.can_right_thread = threading.Thread(target=self.can_pub,args=("right",self.right_hand_joint))
        self.can_right_thread.daemon = True
        self.can_right_thread.start()
        # 右手发布状态
        self.pub_right_status = rospy.Publisher("/cb_right_hand_state", JointState, queue_size=10)
        rospy.Timer(rospy.Duration(1.0 / 60.0), self.pub_right_status_cb)
        self.lh_r_sub = rospy.Subscriber("/cb_right_hand_control_cmd", JointState, self.right_hand_cb)



    def left_hand_cb(self, msg): # 左手
        """接收到/cb_left_hand_control_cmd话题回调"""
        position = msg.position
        self.lh_l_last_pose = position
        #ColorMsg(msg=f"接收到左手数据：{list(self.lh_l_last_pose)}", color="green")


    def right_hand_cb(self, msg): # 右手
        """接收到/cb_right_hand_control_cmd话题回调"""
        position = msg.position
        self.lh_r_last_pose = position
        #ColorMsg(msg=f"接收到右手数据：{list(self.lh_r_last_pose)}", color="green")
    def can_pub(self, arg1,arg2):
        while True:
            with self.lock:
                if arg1 == "left":
                    last_pose = self.lh_l_last_pose
                    con = self.lh_l
                    if len(last_pose) == 0:
                        continue
                    if len(last_pose) >= 16 and self.left_hand_joint >=16:
                        finger_base, yaw_angles, thumb_yaw, finger_tip = self.pose_slice(p=last_pose)
                        self.send(finger_base, yaw_angles, thumb_yaw, finger_tip,con)
                    elif len(last_pose) == 10 and self.left_hand_joint == 10:
                        self.send_l10(last_pose,con)
                    else:
                        ColorMsg(msg="topic数据格式错误，当前为L20",color="red")
                else:
                    last_pose = self.lh_r_last_pose
                    con = self.lh_r
                    if len(last_pose) == 0:
                        continue
                    if len(last_pose) >= 16 and self.right_hand_joint >=16:
                        finger_base, yaw_angles, thumb_yaw, finger_tip = self.pose_slice(p=last_pose)
                        self.send(finger_base, yaw_angles, thumb_yaw, finger_tip,con)
                        
                    elif len(last_pose) == 10 and self.right_hand_joint == 10:
                        self.send_l10(last_pose,con)
                    else:
                        ColorMsg(msg="topic数据格式错误，当前为L10",color="red")
                self.rate.sleep()
                self.lh_l_last_pose, self.lh_r_last_pose = [],[]
    def pose_slice(self, p):
        """将关节数组切片为手指动作数组"""
        finger_base = [int(val) for val in p[0:5]]   # 手指根部
        yaw_angles = [int(val) for val in p[5:10]]    # 横摆
        thumb_yaw = [int(val) for val in p[10:15]]     # 拇指向手心横摆，其他为0
        finger_tip = [int(val) for val in p[15:20]]    # 指尖弯曲
        return finger_base, yaw_angles, thumb_yaw, finger_tip
    
    # 发送can数据
    def send(self,finger_base, yaw_angles, thumb_yaw, finger_tip,con):
        con.set_thumb_roll(thumb_yaw) # 大拇想手心横摆指移动
        con.set_finger_tip(finger_tip) # 指尖移动
        con.set_finger_base(finger_base) # 手指根部移动
        con.set_finger_middle(yaw_angles) # 横摆移动

    def send_l10(self,last_pose, con):
        con.set_joint_positions(last_pose)

    def hand_setting_cb(self, msg):
        hand_left, hand_right = False, False
        try:
            data = json.loads(msg.data)
            print(f"收到设置命令：{data['setting_cmd']}")
            print(data)
            if data["params"]["hand_type"] == "left" and self.left_hand_exists:
                hand = self.lh_l
                hand_left = True
            elif data["params"]["hand_type"] == "right" and self.right_hand_exists:
                hand = self.lh_r
                hand_right = True
            else:
                print("请指定要设定的手部位")
                return
            # 设置最大扭矩
            if data["setting_cmd"] == "set_max_torque_limits": # 设置最大扭矩
                # 首先判断左右手
                if data["params"]["hand_type"] == "left":
                    if self.left_hand_joint == 10:# 判断是否为L10
                        torque = int(data["params"]["torque"])
                        ColorMsg(msg=f"设置L10左手最大扭矩为{torque}", color="yellow")
                        hand.set_max_torque_limits(pressures=[torque] * 5)
                    elif self.left_hand_joint >= 16:# 判断是否为L20
                        ColorMsg(msg=f"L20左手不支持扭矩设置", color="red")
                        pass
                if data["params"]["hand_type"] == "right":
                    if self.right_hand_joint == 10:# 判断是否为L10
                        torque = int(data["params"]["torque"])
                        ColorMsg(msg=f"设置L10左手最大扭矩为{torque}", color="yellow")
                        hand.set_max_torque_limits(pressures=[torque] * 5)
                    elif self.right_hand_joint >= 16:# 判断是否为L20
                        ColorMsg(msg=f"L20右手不支持扭矩设置", color="red")
                        pass
                
            if data["setting_cmd"] == "set_speed": # 设置速度
                if hand_left == True and self.left_hand_joint < 16 :
                    ColorMsg(msg=f"L10不能调整速度")
                elif hand_right == True and self.right_hand_joint < 16 :
                    ColorMsg(msg=f"L10不能调整速度")
                else:
                    speed = [int(data["params"]["speed"])] * 5
                    hand.set_joint_speed(speed=speed)

            
            if data["setting_cmd"] == "clear_faults": # 清除错误
                if hand_left == True and self.left_hand_joint < 16 :
                    ColorMsg(msg=f"L10左手不能清除错误")
                elif hand_right == True and self.right_hand_joint < 16 :
                    ColorMsg(msg=f"L10右手不能清除错误")
                else:
                    hand.clear_faults()
            if data["setting_cmd"] == "get_faults": # 清除错误
                if hand_left == True and self.left_hand_joint < 16 :
                    ColorMsg(msg=f"L10左手不能获取错误")
                elif hand_right == True and self.right_hand_joint < 16 :
                    ColorMsg(msg=f"L10右手不能获取错误")
                else:
                    hand.get_faults()
            if data["setting_cmd"] == "electric_current": # 获取电流
                if hand_left == True and self.left_hand_joint < 16 :
                    ColorMsg(msg=f"L10左手不能获取电压")
                elif hand_right == True and self.right_hand_joint < 16 :
                    ColorMsg(msg=f"L10右手不能获取电压")
                else:
                    hand.get_electric_current()
            if data["setting_cmd"] == "set_electric_current": # 设置电流
                if hand_left == True and self.left_hand_joint < 16 :
                    ColorMsg(msg=f"L10左手不能获取电压")
                elif hand_right == True and self.right_hand_joint < 16 :
                    ColorMsg(msg=f"L10右手不能获取电压")
                else:
                    tmp = int(data["params"]["electric_current"])
                    e_c = [tmp] * 5
                    hand.set_electric_current(e_c=e_c)
        except:
            ColorMsg(msg=f"命令参数错误", color="red")
            
    def pub_left_status_cb(self,event):
        if self.left_hand_exists:
            current_pose = self.lh_l.get_current_status()
            msg = self.create_joint_state_msg(current_pose, self.left_hand_names)
            self.pub_left_status.publish(msg)

    def pub_right_status_cb(self,event):
        if self.right_hand_exists:
            current_pose = self.lh_r.get_current_status()
            msg = self.create_joint_state_msg(current_pose, self.right_hand_names)
            self.pub_right_status.publish(msg)

    # 左手压力传感器
    def pub_left_touch_cb(self, event):
        self.lh_l.get_normal_force()
        time.sleep(0.01)
        self.lh_l.get_tangential_force()
        time.sleep(0.01)
        self.lh_l.get_tangential_force_dir()
        time.sleep(0.01)
        self.lh_l.get_approach_inc()
        time.sleep(0.01)
        d = self.lh_l.get_force()
        try:
            #print(d)
            msg = Float32MultiArray()
            msg.data = [item for sublist in d for item in sublist]
            self.lh_l_pressure_pub.publish(msg)
            time.sleep(0.01)
        except Exception as e:
            print(e)
    # 右手压力传感器
    def pub_right_touch_cb(self, event):
        self.lh_r.get_normal_force()
        time.sleep(0.01)
        self.lh_r.get_tangential_force()
        time.sleep(0.01)
        self.lh_r.get_tangential_force_dir()
        time.sleep(0.01)
        self.lh_r.get_approach_inc()
        time.sleep(0.01)
        d = self.lh_r.get_force()
        try:
            #print(d)
            msg = Float32MultiArray()
            msg.data = [item for sublist in d for item in sublist]
            self.lh_r_pressure_pub.publish(msg)
            time.sleep(0.01)
        except Exception as e:
            print(e)


    def create_joint_state_msg(self, position, names):
        msg = JointState()
        msg.header = Header()
        msg.header.stamp = rospy.Time.now()
        msg.name = names
        msg.position = list(map(float, position))
        msg.velocity = [0.0] * len(position)
        msg.effort = [0.0] * len(position)
        return msg

    def load_yaml(self):
        try:
            settings_yaml_path = package_path + "/config/setting.yaml"
            with open(settings_yaml_path, 'r', encoding='utf-8') as file:
                config = yaml.safe_load(file)
                self.config = config
                self.left_hand_exists = config['LINKER_HAND']['LEFT_HAND']['EXISTS']
                self.left_hand_names = config['LINKER_HAND']['LEFT_HAND']['NAME']
                self.left_hand_joint = config['LINKER_HAND']['LEFT_HAND']['JOINT']
                self.right_hand_exists = config['LINKER_HAND']['RIGHT_HAND']['EXISTS']
                self.right_hand_names = config['LINKER_HAND']['RIGHT_HAND']['NAME']
                self.right_hand_joint = config['LINKER_HAND']['RIGHT_HAND']['JOINT']
                self.password = config['PASSWORD']
        except Exception as e:
            rospy.logerr(f"Error reading setting.yaml: {e}")

    def open_can0(self):
        try:
            # 检查 can0 接口是否已存在并处于 up 状态
            result = subprocess.run(
                ["ip", "link", "show", "can0"],
                check=True,
                text=True,
                capture_output=True
            )
            if "state UP" in result.stdout:
                rospy.loginfo("CAN接口已经是 UP 状态")
                return
            # 如果没有处于 UP 状态，则配置接口
            subprocess.run(
                ["sudo", "-S", "ip", "link", "set", "can0", "up", "type", "can", "bitrate", "1000000"],
                input=f"{self.password}\n",
                check=True,
                text=True,
                capture_output=True
            )
            rospy.loginfo("CAN接口设置成功")
        except subprocess.CalledProcessError as e:
            rospy.logerr(f"CAN接口设置失败: {e.stderr}")
        except Exception as e:
            rospy.logerr(f"发生错误: {str(e)}")

    def is_can_up_sysfs(self, interface="can0"):
    # 检查接口目录是否存在
        if not os.path.exists(f"/sys/class/net/{interface}"):
            return False
        # 读取接口状态
        try:
            with open(f"/sys/class/net/{interface}/operstate", "r") as f:
                state = f.read().strip()
            if state == "up":
                self.can_status = True
            return self.can_status
        except Exception as e:
            print(f"Error reading CAN interface state: {e}")
            return False
    def shutdown(self):
        self.lh_l.close_can_interface()
        self.lh_r.close_can_interface()
        self.shutdown_flag.set()
        self.can_left_thread.join()
        self.can_right_thread.join()
    
def signal_handler(sig, frame):
    # rospy.loginfo("Shutting down ROS node...")
    # rospy.signal_shutdown("SIGINT received")
    # rospy.on_shutdown()
    sys.exit(0)  # 正常退出程序
if __name__ == '__main__':
    # 注册信号处理器
    signal.signal(signal.SIGINT, signal_handler)  # Ctrl+C
    signal.signal(signal.SIGTERM, signal_handler)  # kill 命令
    try:
        linker_hand = LinkerHand()
        rospy.spin()
    except rospy.ROSInterruptException:
        linker_hand.shutdown()
        rospy.loginfo("Node shutdown complete.")